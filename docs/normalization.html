---

title: Normalization


keywords: fastai
sidebar: home_sidebar



nb_path: "01_normalization.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 01_normalization.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Within-condition-normalization">Within-condition normalization<a class="anchor-link" href="#Within-condition-normalization"> </a></h2><p>It is common practice and highly recommended to measure multiple samples of a given condition. This ensures that observed changes between conditions are not just due to random variation. Examples of samples within the same condition could be biological replicates, but also patients with the same clinical condition. 
We want to ensure that systematic changes between within-condition samples are corrected for as follows:</p>
<ul>
<li><p>Our assumed input values are log2 transformed peptide ion intensities, which are stored in a 2d numpy array called "samples". Each row in samples represents one peptide intensity and each column represents a sample</p>
</li>
<li><p>In a first step, we determine the all pairwise distances between the samples (details explained below)</p>
</li>
<li>We then choose the pair of samples with the closest distance between each other</li>
<li>We randomly choose one "anchor" sample and one "shift" sample and we subtract the distance between the samples from each peptide intensity measured in the "shift" sample. This is equivalent to rescaling the intensities of the original sample by a constant factor, such that the median values of both distributions are equal.</li>
<li>We then construct a virtual "merged" sample by computing the average intensities of anchor and shift sample</li>
<li>We repeat the steps above until all samples are merged. Keeping track of the shift factors allows us then to determine an ideal shift for each sample</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="normalize_withincond" class="doc_header"><code>normalize_withincond</code><a href="https://github.com/ammarcsj/ms_empire/tree/master/ms_empire/normalization.py#L10" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>normalize_withincond</code>(<strong><code>samples</code></strong>)</p>
</blockquote>
<p>finds optimal scaling factors for samples measured in the same condition and corrects the samples by these scaling factors</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Find-the-best-matching-pair">Find the best matching pair<a class="anchor-link" href="#Find-the-best-matching-pair"> </a></h3><p>Take all pairs of the columns in the "samples" array that have not been already merged and compute the distance between the pairs as follows:</p>
<ul>
<li>Subtract sample1 from sample2 (or sample2 from sample1, the order does not matter)</li>
<li>This results in a distribution of differences. As the samples array contains log2 intensities, this corresponds to taking log2 fold changes</li>
<li>Take the median of the distribution, this is a good approximation for the change between the two distributions</li>
<li>Select the two samples with the lowest absolute change</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_bestmatch_pair" class="doc_header"><code>get_bestmatch_pair</code><a href="https://github.com/ammarcsj/ms_empire/tree/master/ms_empire/normalization.py#L43" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_bestmatch_pair</code>(<strong><code>samples</code></strong>, <strong><code>exclusion_set</code></strong>, <strong><code>sample2counts</code></strong>)</p>
</blockquote>
<p>finds the pair of samples whose median values are closest to each other</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_fcdistrib" class="doc_header"><code>get_fcdistrib</code><a href="https://github.com/ammarcsj/ms_empire/tree/master/ms_empire/normalization.py#L65" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_fcdistrib</code>(<strong><code>logvals_rep1</code></strong>, <strong><code>logvals_rep2</code></strong>)</p>
</blockquote>
<p>generates difference distribution between two samples</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="determine_anchor_and_shift_sample" class="doc_header"><code>determine_anchor_and_shift_sample</code><a href="https://github.com/ammarcsj/ms_empire/tree/master/ms_empire/normalization.py#L72" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>determine_anchor_and_shift_sample</code>(<strong><code>sample2counts</code></strong>, <strong><code>i_min</code></strong>, <strong><code>j_min</code></strong>, <strong><code>min_distance</code></strong>)</p>
</blockquote>
<p>given two samples, determine the sample with fewer merges as the shift</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Shifting-samples">Shifting samples<a class="anchor-link" href="#Shifting-samples"> </a></h3><p>When we have computed the distance between two samples, we want to correct one of the samples by this distance. This results in two distributions with the same median value. We always shift the sample which has been merged from fewer distributions (see below for details). The sample to which the shift is applied is call "shift" sample and the sample which is not shifted is called "anchor" sample.
A "total shift" is calculated after all samples are merged, just by following up how many shifts have been applied to a sample in total</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="shift_samples" class="doc_header"><code>shift_samples</code><a href="https://github.com/ammarcsj/ms_empire/tree/master/ms_empire/normalization.py#L84" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>shift_samples</code>(<strong><code>samples</code></strong>, <strong><code>sampleidx2anchoridx</code></strong>, <strong><code>sample2shift</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_total_shift" class="doc_header"><code>get_total_shift</code><a href="https://github.com/ammarcsj/ms_empire/tree/master/ms_empire/normalization.py#L90" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_total_shift</code>(<strong><code>sampleidx2anchoridx</code></strong>, <strong><code>sample2shift</code></strong>, <strong><code>sample_idx</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="sd">&quot;&quot;&quot; #hide</span>
<span class="sd">def test_shift_samples():</span>
<span class="sd">    #assume we shift sample 1 to 2, and then sample 2 to 3</span>
<span class="sd">    sampleidx2anchoridx_test = {0:1, 1:2}</span>
<span class="sd">    #the first shift is 5 and the second shift is 10</span>
<span class="sd">    sample2shift_test = {0:5, 1:5,2:0}</span>
<span class="sd">    samples_test = np.array([[1,1,1], [6,6,6], [11,11,11]])</span>
<span class="sd">    print(shift_samples(samples_test, sampleidx2anchoridx_test,sample2shift_test))</span>
<span class="sd">    assert shift_samples(samples_test, sampleidx2anchoridx_test,sample2shift_test) == np.array([[1,1,1], [1,1,1], [1,1,1]])</span>

<span class="sd">test_shift_samples() &quot;&quot;&quot;</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>&#39; #hide\ndef test_shift_samples():\n    #assume we shift sample 1 to 2, and then sample 2 to 3\n    sampleidx2anchoridx_test = {0:1, 1:2}\n    #the first shift is 5 and the second shift is 10\n    sample2shift_test = {0:5, 1:5,2:0}\n    samples_test = np.array([[1,1,1], [6,6,6], [11,11,11]])\n    print(shift_samples(samples_test, sampleidx2anchoridx_test,sample2shift_test))\n    assert shift_samples(samples_test, sampleidx2anchoridx_test,sample2shift_test) == np.array([[1,1,1], [1,1,1], [1,1,1]])\n\ntest_shift_samples() &#39;</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Merging-distributions">Merging distributions<a class="anchor-link" href="#Merging-distributions"> </a></h3><p>After we shift two distributions on top of each other, we calculate a "merged" distribution. Each intensity in the merged distribution is the average of the intensity in both distributions. For the merging we have to take into account the following: If for example the anchor sample has already been merged from 10 samples, and the shift distribution has not been merged at all, we want to weigh the distribution coming from many samples higher. We hence multiply each sample by the number of merges.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="merge_distribs" class="doc_header"><code>merge_distribs</code><a href="https://github.com/ammarcsj/ms_empire/tree/master/ms_empire/normalization.py#L104" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>merge_distribs</code>(<strong><code>anchor_distrib</code></strong>, <strong><code>shifted_distrib</code></strong>, <strong><code>counts_anchor_distrib</code></strong>, <strong><code>counts_shifted_distrib</code></strong>)</p>
</blockquote>
<p>Calculate the average peptide intensities to merge two peptide distributions</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

</div>
 

