# AUTOGENERATED! DO NOT EDIT! File to edit: 04_diff_analysis.ipynb (unless otherwise specified).

__all__ = ['DifferentialIon', 'calc_diffreg_peptide', 'calc_outlier_scaling_factor', 'DifferentialProtein',
           'evaluate_protein_expression', 'select_robust_if_many_ions', 'calc_pseudo_intensities',
           'select_representative_DIA_fragions', 'group_ions_by_precursor']

# Cell
from scipy.stats import norm
import numpy as np
import math
import statistics

class DifferentialIon():

    def __init__(self,noNanvals_from, noNanvals_to, diffDist, name, outlier_correction = True):
        self.usable = False
        self.name = name
        p_val, fc, z_val = calc_diffreg_peptide(noNanvals_from, noNanvals_to, diffDist, name, outlier_correction)
        if (p_val!=None):
            self.p_val=p_val
            self.fc=fc
            self.z_val = z_val
            self.usable = True

def calc_diffreg_peptide(noNanvals_from, noNanvals_to, diffDist, name, outlier_correction):

    nrep_from = len(noNanvals_from)
    nrep_to = len(noNanvals_to)



    if ((nrep_from==0) or (nrep_to ==0)):
        return None, None, None
    var_from = diffDist.var_from
    var_to = diffDist.var_to

    perEvidenceVariance = diffDist.var + (nrep_to-1) * var_from + (nrep_from-1) * var_to
    totalVariance = perEvidenceVariance*nrep_to * nrep_from
    outlier_scaling_factor = 1.0
    if outlier_correction:
        outlier_scaling_factor = calc_outlier_scaling_factor(noNanvals_from, noNanvals_to, diffDist)

    fc_sum =0
    z_sum=0
    unscaled_zs = []
    fcs = []
    for from_intens in noNanvals_from:
        for to_intens in noNanvals_to:
            fc = from_intens - to_intens
            fcs.append(fc)
            fc_sum+=fc
            z_unscaled = diffDist.calc_zscore_from_fc(fc)
            unscaled_zs.append(z_unscaled)
            z_sum += z_unscaled/outlier_scaling_factor

    fc = fc_sum/(nrep_from * nrep_to)
    scaled_SD =  math.sqrt(totalVariance/diffDist.var)*outlier_scaling_factor
    p_val = 2.0 * (1.0 -  norm(loc=0, scale= scaled_SD).cdf(abs(z_sum)))
    z_val = z_sum/scaled_SD

    return p_val, fc, z_val

  #self.var_from = from_dist.var
   #     self.var_to

def calc_outlier_scaling_factor(noNanvals_from, noNanvals_to, diffDist):
    sd_from = math.sqrt(diffDist.var_from)
    sd_to = math.sqrt(diffDist.var_to)
    median_from = statistics.median(noNanvals_from)
    median_to = statistics.median(noNanvals_to)

    between_rep_SD_from = math.sqrt(sum(np.square(noNanvals_from-median_from))/len(noNanvals_from)) if len(noNanvals_from)>1 else sd_from
    between_rep_SD_to = math.sqrt(sum(np.square(noNanvals_to-median_to))/len(noNanvals_to)) if len(noNanvals_to)>1 else sd_to

    highest_SD_from = max(between_rep_SD_from, sd_from)
    highest_SD_to = max(between_rep_SD_to, sd_to)
    highest_SD_combined = math.sqrt(highest_SD_from**2 + highest_SD_to**2)

    scaling_factor = max(1.0, highest_SD_combined/diffDist.SD)
    return scaling_factor

# Cell
import math
import statistics
from scipy.stats import norm
import numpy as np
import alphaquant.diffquant_utils as aqutils
class DifferentialProtein():

    def __init__(self, name, ion_diffresults, median_offset, dia_fragment_selection = False):
        self.name = name
        if dia_fragment_selection:
            ion_diffresults = select_representative_DIA_fragions(ion_diffresults)

        fc, pval, ions = evaluate_protein_expression(ion_diffresults, median_offset)

        self.pval=pval
        self.fc=fc
        self.ions = ions
        self.num_ions = len(ions)



def evaluate_protein_expression(ion_diffresults, median_offset):
    ion_diffresults = list(filter(lambda _f : _f.usable, ion_diffresults))

    if len(ion_diffresults) ==0:
        return
    fcs = list(map(lambda _dr : _dr.fc,ion_diffresults))
    median_fc = np.median(fcs)


    ion_diffresults, median_offset_fc = select_robust_if_many_ions(fcs, median_fc,ion_diffresults)


    z_sum = sum(map(lambda _dr: _dr.z_val, ion_diffresults))
    p_val = 2.0 * (1.0 - norm(0, math.sqrt(len(ion_diffresults))).cdf(abs(z_sum)))
    ions = list(map(lambda _dr : _dr.name, ion_diffresults))

    prot_fc = median_offset_fc if median_offset else median_fc
    return prot_fc, p_val, ions


def select_robust_if_many_ions(fcs, median_fc,ion_diffresults):
    ninety_perc_cutoff = math.ceil(0.9*len(ion_diffresults)) #the ceil function ensures that ions are only excluded if there are more than 10 available
    ion_diffresults = sorted(ion_diffresults, key = lambda _dr : abs(_dr.fc - median_fc))
    if ninety_perc_cutoff >0:
        ion_diffresults = ion_diffresults[:ninety_perc_cutoff]
    median_offset_fc = aqutils.get_middle_elem(list(map(lambda _dr : _dr.fc,ion_diffresults)))
    return ion_diffresults, median_offset_fc

# Cell
import numpy as np

def calc_pseudo_intensities(normed_df_c2, pep2prot, cond_prots, cond_fcs,condpair):
    summed_df = normed_df_c2.copy()
    numrep = len(normed_df_c2.columns)-1
    print(f"numrep {numrep}")
    display(normed_df_c2)
    summed_df["summed_int"] = normed_df_c2["median"]+numrep#summed_df.sum(axis=1)
    summed_df["summed_int"] = np.exp2(summed_df["summed_int"])
    summed_df = summed_df[["summed_int"]]
    summed_df["protein"] = list(map(lambda x: pep2prot.get(x),summed_df.index))
    summed_df = summed_df.reset_index()
    summed_df = summed_df.set_index(['protein', 'ion'])
    summed_df = summed_df.sum(level='protein')
    prot2int = dict(zip(summed_df.index, summed_df["summed_int"]))
    pseudoint1 = list(map(lambda x : prot2int.get(x),cond_prots))*np.exp2(cond_fcs)
    pseudoint2 = list(map(lambda x : prot2int.get(x),cond_prots))
    return pseudoint1, pseudoint2

# Cell
import re
import numpy as np
# class DifferentialIon():

#     def __init__(self,name, fc):
#         self.usable = False
#         self.name = name
#         self.fc = fc
# ions= ["_LRTDETLR_.2_b6", "_LRTDETLR_.2_y6","_LTGNPELSSLDEVLAK_.2_y10","_LTGNPELSSLDEVLAK_.2_y12","_LTGNPELSSLDEVLAK_.2_y9","_IFALVFSSNER_.2_b3","_IFALVFSSNER_.2_y5","_IFALVFSSNER_.2_y6","_YFFWLQEK_.2_y3","_YFFWLQEK_.2_y4","_KVTQMTPAPK_.2_b8","_KVTQMTPAPK_.2_y4","_KVTQMTPAPK_.2_y8","_KVTQMTPAPK_.2_y9","_VTQMTPAPK_.2_y4"]
# fcs = np.random.rand(len(ions))

# diffions = [DifferentialIon(ions[x], fcs[x]) for x in range(len(ions))]

def select_representative_DIA_fragions(diffions):
    filtered_ions = []
    precursor2ions = group_ions_by_precursor(diffions)
    for precursor in precursor2ions.keys():
        ions = precursor2ions.get(precursor)
        ions.sort(key = lambda x : x.fc)
        representative_ion = ions[int(np.round(len(ions)/2))]
        filtered_ions.append(representative_ion)
    return filtered_ions


def group_ions_by_precursor(diffions):
    pattern_specnaut = "(.*\.\d{0,1}_)(.*)"
    pattern_diann = "(.*_)(fion.*)"
    if (re.match(pattern_specnaut, diffions[0].name)):
        pattern = pattern_specnaut
    if (re.match(pattern_diann, diffions[0].name)):
        pattern = pattern_diann
    if pattern == None:
        raise Exception("fragment ion not recognized!")

    precursor2ions = {}
    for ion in diffions:
        m = re.match(pattern, ion.name)
        precursor = m.group(1)
        if precursor not in precursor2ions.keys():
            precursor2ions[precursor] = list()
        precursor2ions[precursor].append(ion)
    return precursor2ions

#select_representative_DIA_fragions(diffions)