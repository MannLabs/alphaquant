# AUTOGENERATED! DO NOT EDIT! File to edit: 14_protein_ptm_normalization.ipynb (unless otherwise specified).

__all__ = ['PTMResultsNormalizer', 'PTMtableLocalizer', 'PTMFiles', 'PTMtableNormalizer', 'PTMtablePreparer',
           'RegulationInfos', 'FDRDamper']

# Cell
import alphaquant.diffquant.diffutils as aqutils
import pathlib
import alphaquant.multicond.multicond_ptmnorm as aq_multicond_ptmnorm
import statsmodels.stats.multitest as mt



class PTMResultsNormalizer():
    def __init__(self, results_dir_ptm, results_dir_proteome, organism = "human"):
        self._table_localizer = PTMtableLocalizer(results_dir_ptm, results_dir_proteome, organism)
        self.results_dir_protnormed = f"{results_dir_ptm}_protnormed"
        self._create_results_dir()
        self._write_normalized_tables_diffquant()
        aq_multicond_ptmnorm.combine_results_tables_if_they_exist(self.results_dir_protnormed)
        print(f"wrote proteome normalized tables to: {self.results_dir_protnormed}")

    def _write_normalized_tables_diffquant(self):
        for ptm_file, protfile in self._table_localizer.get_ptmfile2protfile().items():
            if protfile == None:
                print(f"could not localize protfile for {ptm_file}, skipping")
                continue
            table_normalizer = PTMtableNormalizer(ptm_file, protfile)
            df_normed = table_normalizer.results_df
            df_summary = table_normalizer.info_df
            df_normed = self._update_fdr_column_normed_df(df_normed)
            self._write_normed_df(df_normed, ptm_file)
            self._write_summary_df(df_summary, ptm_file)

    def _create_results_dir(self):
        aqutils.create_or_replace_folder(self.results_dir_protnormed)

    def _update_fdr_column_normed_df(self, df_normed):
        pvals = df_normed["p_value"].tolist()
        fdrs = mt.multipletests(pvals, method='fdr_bh', is_sorted=False, returnsorted=False)[1]
        df_normed["fdr"] = fdrs
        return df_normed


    def _write_normed_df(self,df_normed, ptmfile):
        ptmfile2name = self._table_localizer.get_ptmfile2name()
        name = ptmfile2name.get(ptmfile)
        df_normed.to_csv(f"{self.results_dir_protnormed}/{name}.results.tsv", sep = "\t")

    def _write_summary_df(self,df_summary, ptmfile):
        ptmfile2name = self._table_localizer.get_ptmfile2name()
        name = ptmfile2name.get(ptmfile)
        df_summary.to_csv(f"{self.results_dir_protnormed}/{name}.summary.tsv", sep = "\t", header = False)


class PTMtableLocalizer():
    def __init__(self, results_dir_ptm, results_dir_proteome, organism = "human"):
        self._files = PTMFiles(results_dir_ptm=results_dir_ptm, results_dir_proteome=results_dir_proteome, organism=organism)
        self._name2ptmfile = self._get_name2ptmfile()
        self._name2protfile = self._get_name2protfile()

    def get_ptmfile2protfile(self):
        phosfile2protfile = {self._name2ptmfile.get(x): self._name2protfile.get(x) for x in self._name2ptmfile.keys()}
        return phosfile2protfile

    def get_ptmfile2name(self):
        return {v: k for k, v in self._name2ptmfile.items()}

    def get_swissprot_reference(self):
        return self._files.swissprot_reference

    def _get_name2ptmfile(self):
        return self._get_name2file(self._files.ptm_result_files)

    def _get_name2protfile(self):
        return self._get_name2file(self._files.proteome_result_files)

    @staticmethod
    def _get_name2file(filenames):
        name2file = {}
        for file in filenames:
            path = pathlib.Path(file)
            if path.name.endswith('.results.tsv'):
                name = path.name.replace('.results.tsv', '')
                name2file.update({name: file})
        return name2file


import alphaquant.ptm.ptmsite_mapping as aqptm
class PTMFiles():
    def __init__(self, results_dir_ptm, results_dir_proteome, organism = "human"):
        self._results_dir_ptm = results_dir_ptm
        self._results_dir_proteome = results_dir_proteome
        self._organism = organism
        
        self.ptm_result_files = self._get_ptm_result_files()
        self.proteome_result_files = self._get_proteome_result_files()
        self.swissprot_reference = self._get_swissprot_reference()

    def _get_ptm_result_files(self):
        return glob.glob(f'{self._results_dir_ptm}/*.results.tsv')

    def _get_proteome_result_files(self):
        return glob.glob(f'{self._results_dir_proteome}/*.results.tsv')

    def _get_swissprot_reference(self):
        return aqptm.get_swissprot_path(organism=self._organism)

class PTMtableNormalizer():
    def __init__(self,  ptm_file, proteome_file):
        self._prepared_tables = PTMtablePreparer(ptm_file, proteome_file)
        self.results_df = self._prepared_tables.ptm_df.copy() #use ptm table as template for the output table and update with normalized fcs and p_values
        self.info_df = None

        self._number_of_excluded_ptms = 0
        self._number_of_included_ptms = 0

        self._normalize_with_proteome()
        self._define_info_df()

    def _normalize_with_proteome(self):
        for ptm in self.results_df.index:
            self._update_ptm_infos(ptm)
    
    def _define_info_df(self):
        info_dict = {}
        info_dict["number_ptms_w_no_matching_protein"] = self._number_of_excluded_ptms
        info_dict["number_ptms_w_matching_protein"] = len(self.results_df.index)
        info_dict["number_proteins_in_ptm_dataset"] = len(set([x.split("_")[1] for x in self._prepared_tables.ptm_df.index]))
        info_dict["number_proteins_in_proteome_dataset"] = self._prepared_tables.proteome_df.shape[0]
        self.info_df = pd.DataFrame.from_dict(info_dict, orient = "index", columns = ["value"])

    def _update_ptm_infos(self, ptm):
        regulation_infos = self._prepared_tables.get_protein_regulation_infos(ptm)
        if regulation_infos is None:
            self.results_df = self.results_df.drop(labels = [ptm])
            self._number_of_excluded_ptms += 1
        else:
            p_value_damper = PvalDamper(regulation_infos)
            dampened_p_value = p_value_damper.get_p_value()
            self._update_values_for_output_table(ptm, dampened_p_value, regulation_infos.diff_fc)


    def _update_values_for_output_table(self, ptm, dampened_p_value, log2fc):
        self.results_df.loc[ptm, "p_value"] = dampened_p_value
        self.results_df.loc[ptm, "log2fc"] = log2fc

    def __get_ptm_list__(self):
        list(self._prepared_tables.ptm_df.index)


# Cell
import glob
import re
import pandas as pd
class PTMtablePreparer():
    def __init__(self, ptm_file, proteome_file):
        self._swissprot_referenceprots = aqptm.get_swissprot_path()
        self.ptm_df = self.__read_and_annotate_ptm_df(ptm_file)
        self.proteome_df = self.__read_and_annotate_proteome_df(proteome_file)
        self.output_df = self.ptm_df.copy()
        self._ptmsite2swissprot  = self.__get_ptmsite2swissprot__()


    def get_protein_regulation_infos(self, ptmsite):
        swissprot = self._ptmsite2swissprot.get(ptmsite)
        ptm_row = self.ptm_df.loc[ptmsite]
        try:
            protein_row = self.proteome_df.loc[swissprot]
            protein_row = self.__resolve_possible_duplicate_protein_rows(protein_row)

        except:
            return None
        ptm_p_value = self.__get_p_value_from_table_row__(ptm_row)
        ptm_fc = self.__get_fc_from_table_row__(ptm_row)
        protein_p_value = self.__get_p_value_from_table_row__(protein_row)
        protein_fc = self.__get_fc_from_table_row__(protein_row)
        reginfos = RegulationInfos(log2fc_ptm=ptm_fc, p_value_ptm=ptm_p_value, log2fc_protein=protein_fc,p_value_protein=protein_p_value)

        return reginfos

    def __resolve_possible_duplicate_protein_rows(self, protein_row): #due to the proteingroup structure, it can happen, that different protein groups have the same swissprot id, which results in multiple rows
        if type(protein_row) != pd.Series: #a single row gets transposed into a pandas series
            protein_row = protein_row.sort_values(by = "pseudoint1", ascsending = False)
            return protein_row.iloc[0]
        else:
            return protein_row

    def __read_and_annotate_ptm_df(self, ptm_file):
        ptm_df = self.__read_dataframe__(ptm_file)
        ptm_df = self.__add_swissprot_name_column(ptm_df)
        ptm_df = ptm_df.set_index("protein")
        return ptm_df

    def __read_and_annotate_proteome_df(self, proteome_file):
        proteome_df = self.__read_dataframe__(proteome_file)
        proteome_df["swissprot"] = aqptm.get_idmap_column(proteome_df["protein"],self._swissprot_referenceprots)#maps the protein identifier(s) to the swissprot reference if possible
        proteome_df = proteome_df.set_index("swissprot")
        return proteome_df

    def __add_swissprot_name_column(self, ptm_df):
        ptm_prots = self.__get_ptm_proteins__(ptm_df)
        ptm_df = self.__match_ptm_df_to_ptm_prots__(ptm_df, ptm_prots)
        ptm_df["swissprot"] = aqptm.get_idmap_column(ptm_prots, self._swissprot_referenceprots)
        return ptm_df

    def __get_ptm_proteins__(self, ptm_df):
        prots = []
        for ptmprot_name in ptm_df["protein"]:
            prot = self.__extract_protein_from_ptmprot_name__(ptmprot_name)
            prots.append(prot)
        return prots

    @staticmethod
    def __extract_protein_from_ptmprot_name__(ptmprot_name):
        if ptmprot_name == None:
            return None
        elif len(ptmprot_name.split("_"))<2:
            return None
        else:
            return ptmprot_name.split("_")[1]
    @staticmethod
    def __match_ptm_df_to_ptm_prots__(ptm_df,ptm_prots):
        return ptm_df[[x != None for x in ptm_prots]]

    def __filter_nonidentified_proteins__(ptm_prots):
        return [x for x in ptm_prots if x != None]

    @staticmethod
    def __read_dataframe__(file):
        return pd.read_csv(file, sep = "\t")

    def __get_ptmsite2swissprot__(self):
        return dict(zip(self.ptm_df.index, self.ptm_df["swissprot"])) #the "protein" column always refers to the identifier, which in this case is the ptmsite

    @staticmethod
    def __get_p_value_from_table_row__(row):
        return float(row["p_value"])

    @staticmethod
    def __get_fc_from_table_row__(row):
        return float(row["log2fc"])




# Cell
import math
import numpy as np

class RegulationInfos():
    def __init__(self, log2fc_ptm, p_value_ptm,log2fc_protein, p_value_protein):
        self.log2fc_ptm = log2fc_ptm
        self.log2fc_protein = log2fc_protein
        self.p_value_ptm = p_value_ptm
        self.p_value_protein = p_value_protein
        self.diff_fc = self._get_protnormed_fc()
        self.switched_regulation_direction = not self._check_if_regulation_stayed_the_same()

    def _get_protnormed_fc(self):
        return self.log2fc_ptm - self.log2fc_protein

    def _check_if_regulation_stayed_the_same(self):
        return np.sign(self.log2fc_ptm) == np.sign(self.diff_fc)



import math
class PvalDamper():
    """The p_value is taken from the regulation of the phosphopeptides. If the protein is regulated
    similar to the phosphopeptide, we for the moment use a very simple heuristic to correct the p_value down:

    1) We only consider phosphopeptides where the fold change has become less strong, i.e. 'dampened' and where the "damping" protein was regulated significantly
    2) We correct the logged(!) p_value up with an exponnential function and then transform it back to a new p_value. This means a exponential decrease in the significance
    """
    def __init__(self, regulation_infos):
        self._regulation_infos = regulation_infos

    def get_p_value(self):
        return self._dampen_p_value_if_needed()

    def _dampen_p_value_if_needed(self):
        if self._check_if_needs_damping():
            return self._get_adjusted_p_value()
        else:
            return self._regulation_infos.p_value_ptm

    def _check_if_needs_damping(self):
        if self._regulation_infos.p_value_protein<0.05:
            if np.sign(self._regulation_infos.log2fc_ptm) == np.sign(self._regulation_infos.log2fc_protein):
                return True
        return False

    def _get_adjusted_p_value(self):
        if self._regulation_infos.switched_regulation_direction:
            return 1.0
        else:
            return self._calculate_damping_factor()

    def _calculate_damping_factor(self):
        factor = self._calculate_order_of_magnitude_damping_factor()
        p_value_new = 10**(math.log10(self._regulation_infos.p_value_ptm)*factor)
        return min(p_value_new, 1)

    def _calculate_order_of_magnitude_damping_factor(self):
        ratio_old_new = self._regulation_infos.diff_fc/self._regulation_infos.log2fc_ptm #must be smaller than 1
        return ratio_old_new
