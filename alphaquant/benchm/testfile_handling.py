# AUTOGENERATED! DO NOT EDIT! File to edit: 13_testfile_handling.ipynb (unless otherwise specified).

__all__ = ['TestFileDownloader', 'DownloadLinkConverter']

# Cell
import yaml
import glob
import subprocess
import sys
import os

import alphaquant.config.config as aqconfig
import logging
aqconfig.setup_logging()
LOGGER = logging.getLogger(__name__)



class TestFileDownloader():
    def __init__(self, test_folder, links_yaml, subfolder_of_interest = None):
        self._test_folder = test_folder
        self._path2link = DownloadLinkConverter(links_yaml, subfolder_of_interest).get_path2link_from_yaml_file()
        self._install_wget_if_missing()

    def download_missing_files(self):
        missing_paths = self._get_missing_paths()
        LOGGER.info(missing_paths)
        for missing_path in missing_paths:
            LOGGER.info(missing_path)
            self._download_file(missing_path)

    def _get_missing_paths(self):
        all_paths = set(self._path2link.keys())
        existing_paths = self._get_existing_paths()
        return all_paths - existing_paths

    def _download_file(self, path):
        import wget
        download_link = self._get_download_link_from_path(path)
        absolute_path = self._convert_relative_to_absolute_path(path)
        self._prepare_download_directory(absolute_path)
        wget.download(download_link, absolute_path)

    def _get_existing_paths(self):
        all_elements = self._get_all_elements_in_all_subdirs(self._test_folder)
        all_filepaths = self._filter_for_files(all_elements)
        all_filepaths_relative = self._convert_to_relative_paths(all_filepaths, self._test_folder)
        return all_filepaths_relative

    def _get_download_link_from_path(self, path):
        link = self._path2link.get(path)
        return f"{link}/download"

    def _convert_relative_to_absolute_path(self, path):
        return f"{self._test_folder}/{path}"

    @staticmethod
    def _prepare_download_directory(absolute_path):
        parent_directory = os.path.dirname(absolute_path)
        if not os.path.exists(parent_directory):
            os.makedirs(parent_directory)


    @staticmethod
    def _get_all_elements_in_all_subdirs(base_dir):
        return glob.glob(f"{base_dir}/**", recursive=True)

    @staticmethod
    def _filter_for_files(list_of_paths):
        return (x for x in list_of_paths if os.path.isfile(x))

    @staticmethod
    def _convert_to_relative_paths(list_of_absolute_paths, base_dir):
        return {x.replace(base_dir, ".") for x in list_of_absolute_paths}

    @staticmethod
    def _install_wget_if_missing():
        subprocess.check_call([sys.executable, "-m", "pip", "install", "wget"])




class DownloadLinkConverter():
    def __init__(self, links_yaml, subfolder_of_interest = None):
        self._links_yaml = links_yaml
        self._subfolder_of_interest = subfolder_of_interest

    def get_path2link_from_yaml_file(self):
        yaml_dict = self._load_dict_from_yaml_file(self._links_yaml)
        path2link_generator = self._convert_nested_dict_to_relpath_dict(nested_dict=yaml_dict)
        path2link_dict = {path : link for path, link in path2link_generator}
        path2link_dict = self._subset_path2link_to_subfolder_of_interest(path2link_dict)
        return path2link_dict

    @staticmethod
    def _load_dict_from_yaml_file(yaml_file):
        stream = open(yaml_file, 'r')
        return yaml.safe_load(stream)

    def _convert_nested_dict_to_relpath_dict(self, nested_dict , rel_path_so_far = "."):
        for path, value in nested_dict.items():
            updated_path = self._get_updated_relpath(rel_path_so_far, path)
            is_dict = self._check_if_value_is_dict(value)
            if is_dict:
                yield from self._convert_nested_dict_to_relpath_dict(value, updated_path)
            else:
                yield updated_path , value

    @staticmethod
    def _get_updated_relpath(rel_path_so_far, new_path):
        return f"{rel_path_so_far}/{new_path}"

    @staticmethod
    def _check_if_value_is_dict(value):
        return isinstance(value, dict)
    
    def _subset_path2link_to_subfolder_of_interest(self, path2link):
        if self._subfolder_of_interest is None:
            return path2link
        return {path: link for path, link in path2link.items() if self._subfolder_of_interest in path}






