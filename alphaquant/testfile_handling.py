# AUTOGENERATED! DO NOT EDIT! File to edit: 13_testfile_handling.ipynb (unless otherwise specified).

__all__ = ['TestFileDownloader', 'DownloadLinkConverter', 'stream', 'yamldict', 'download_links', 'relpath_dict']

# Cell
import os
import pathlib
if "__file__" in globals():#only run in the nbdev translated python file, as __file__ is not defined with ipython
    download_links = os.path.join(pathlib.Path(__file__).parent.absolute(), "configs", "testfile_download_links.yaml") #the yaml config is located one directory below the python library files



# Cell
import yaml

class TestFileDownloader():
    def __init__(self, test_folder, links_yaml):
        self._test_folder = test_folder
        self._path2link = DownloadLinkConverter(links_yaml).load_path2link_from_yaml_file()
        self.__initialize_wget_install_if_missing__()

    def __initialize_wget_install_if_missing__():
        try:
            import wget
        except ImportError:
            %pip install wget
            import wget

    def download_missing_files(self):
        missing_paths = self.__get_missing_paths__()
        for missing_path in missing_paths:
            self.__download_file__(missing_path)

    def __get_missing_paths__(self):
        all_paths = self._path2link.keys()
        existing_paths = self.__get_existing_paths__()
        return all_paths - existing_paths

    def __download_file__(self, path):
        link = self._path2link.get(path)
        download_link = f"{link}/download"
        wget.download(download_link, path)

    def __get_existing_paths__(self):
        all_elements = self.__get_all_elements_in_all_subdirs__(self._test_folder)
        all_filepaths = self.__filter_for_files__(all_elements)
        all_filepaths_relative = self.__convert_to_relative_paths__(all_filepaths, self._test_folder)
        return all_filepaths_relative

    @staticmethod
    def __get_all_elements_in_all_subdirs__(base_dir):
        return glob.glob(f"{base_dir}/**", recursive=True)

    @staticmethod
    def __filter_for_files__(list_of_paths):
        return (x for x in list_of_paths if os.path.isfile(x))

    @staticmethod
    def __convert_to_relative_paths__(list_of_absolute_paths, base_dir):
        return {x.replace(base_dir, ".") for x in list_of_absolute_paths}


class DownloadLinkConverter():
    def __init__(self, links_yaml):
        self._links_yaml = links_yaml

    def get_path2link_from_yaml_file(self):
        yaml_dict = self.__load_dict_from_yaml_file__(self._links_yaml)
        path2link = self.__convert_nested_dict_to_relpath_dict__(nested_dict=yaml_dict)
        return path2link

    @staticmethod
    def __load_dict_from_yaml_file__(yaml_file):
        stream = open(yaml_file, 'r')
        return yaml.safe_load(stream)

    def __convert_nested_dict_to_relpath_dict__(self, nested_dict , rel_path_so_far = "."):
        for path, value in nested_dict.items():
            updated_path = self.__get_updated_relpath__(rel_path_so_far, path)
            is_dict = self.__check_if_value_is_dict__(value)
            if is_dict:
                self.__recursively_call_sub_dictionary__(sub_dictionary = value, updated_path=updated_path)
            else:
                self.__yield_path2link_pair__(updated_path=updated_path, link=value)

    def __recursively_call_sub_dictionary__(self, sub_dictionary, updated_path):
        yield from self.__convert_nested_dict_to_relpath_dict__(sub_dictionary, updated_path) #yield from allows to recursively trigger the generator

    @staticmethod
    def __get_updated_relpath__(rel_path_so_far, new_path):
        return f"{rel_path_so_far}/{new_path}/"

    @staticmethod
    def __check_if_value_is_dict__(value, dict):
        return isinstance(value, dict)

    @staticmethod
    def __yield_path2link_pair__(updated_path, link):
        yield updated_path , link









stream = open(, 'r')
yamldict =  yaml.safe_load(stream)

download_links = "/Users/constantin/workspace/alphaquant/alphaquant/configs/download_links_for_testfiles.yaml"



relpath_dict = {x : y for x,y in __generate_relpaths_from_nested_dict__(yamldict)}

print(relpath_dict)