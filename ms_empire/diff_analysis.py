# AUTOGENERATED! DO NOT EDIT! File to edit: 04_diff_analysis.ipynb (unless otherwise specified).

__all__ = ['DifferentialIon', 'calc_diffreg_peptide', 'calc_outlier_scaling_factor', 'DifferentialProtein']

# Cell
from .background_distributions import *
from .diffquant_utils import *

# Cell
from scipy.stats import norm
import numpy as np
import math
import statistics

class DifferentialIon():

    def __init__(self,noNanvals_from, noNanvals_to, diffDist, name, outlier_correction = True):
        self.usable = False
        self.name = name
        p_val, fc, z_val = calc_diffreg_peptide(noNanvals_from, noNanvals_to, diffDist, name, outlier_correction)
        if (p_val!=None):
            self.p_val=p_val
            self.fc=fc
            self.z_val = z_val
            self.usable = True

def calc_diffreg_peptide(noNanvals_from, noNanvals_to, diffDist, name, outlier_correction): #TO Do normalize the input vectors between conds
    weird_ions = ["FPEDLENDIR", "TMPGGNDHEIFTDPR", "TVVVVGTVTDDAR"] #DEBUG

    nrep_from = len(noNanvals_from)
    nrep_to = len(noNanvals_to)



    if ((nrep_from==0) or (nrep_to ==0)):
        return None, None, None
    var_from = diffDist.var_from
    var_to = diffDist.var_to

    perEvidenceVariance = diffDist.var + (nrep_to-1) * var_from + (nrep_from-1) * var_to
    totalVariance = perEvidenceVariance*nrep_to * nrep_from
    outlier_scaling_factor = 1.0
    if outlier_correction:
        outlier_scaling_factor = calc_outlier_scaling_factor(noNanvals_from, noNanvals_to, diffDist)

    fc_sum =0
    z_sum=0
    unscaled_zs = []
    fcs = []
    for from_intens in noNanvals_from:
        for to_intens in noNanvals_to:
            fc = from_intens - to_intens
            fcs.append(fc)
            fc_sum+=fc
            z_unscaled = diffDist.calc_zscore_from_fc(fc)
            unscaled_zs.append(z_unscaled)
            z_sum += z_unscaled/outlier_scaling_factor

    fc = fc_sum/(nrep_from * nrep_to)
    scaled_SD =  math.sqrt(totalVariance/diffDist.var)*outlier_scaling_factor
    p_val = 2.0 * (1.0 -  norm(loc=0, scale= scaled_SD).cdf(abs(z_sum)))
    z_val = z_sum/scaled_SD
    if name in weird_ions:
        fcs.sort()
        unscaled_zs.sort()
        print(name)
        print(f"fcs {fcs}")
        print(f"zvals {unscaled_zs}")
        print(f"BG SD {math.sqrt(diffDist.var)} pval {p_val} zval {z_val} total var {totalVariance} scaling factor {outlier_scaling_factor} scaled SD {scaled_SD} zsum {z_sum}")
    return p_val, fc, z_val

  #self.var_from = from_dist.var
   #     self.var_to

def calc_outlier_scaling_factor(noNanvals_from, noNanvals_to, diffDist):
    sd_from = math.sqrt(diffDist.var_from)
    sd_to = math.sqrt(diffDist.var_to)
    median_from = statistics.median(noNanvals_from)
    median_to = statistics.median(noNanvals_to)

    between_rep_SD_from = math.sqrt(sum(np.square(noNanvals_from-median_from))/len(noNanvals_from)) if len(noNanvals_from)>1 else sd_from
    between_rep_SD_to = math.sqrt(sum(np.square(noNanvals_to-median_to))/len(noNanvals_to)) if len(noNanvals_to)>1 else sd_to

    highest_SD_from = max(between_rep_SD_from, sd_from)
    highest_SD_to = max(between_rep_SD_to, sd_to)
    highest_SD_combined = math.sqrt(highest_SD_from**2 + highest_SD_to**2)

    scaling_factor = max(1.0, highest_SD_combined/diffDist.SD)
    return scaling_factor


# Cell
import math
import statistics
from scipy.stats import norm
import numpy as np

class DifferentialProtein():

    def __init__(self, name, ion_diffresults):
        self.name = name
        fc, pval, ions = self.evaluate_protein_expression(ion_diffresults)
        self.pval=pval
        self.fc=fc
        self.ions = ions
        self.num_ions = len(ions)



    def evaluate_protein_expression(self, ion_diffresults):
        ion_diffresults = list(filter(lambda _f : _f.usable, ion_diffresults))

        if len(ion_diffresults) ==0:
            return
        fcs = list(map(lambda _dr : _dr.fc,ion_diffresults))
        median_fc = np.median(fcs)


        ion_diffresults, median_offset_fc = self.select_robust_if_many_ions(fcs, median_fc,ion_diffresults)


        z_sum = sum(map(lambda _dr: _dr.z_val, ion_diffresults))
        p_val = 2.0 * (1.0 - norm(0, math.sqrt(len(ion_diffresults))).cdf(abs(z_sum)))
        ions = list(map(lambda _dr : _dr.name, ion_diffresults))
        return median_offset_fc, p_val, ions


    def select_robust_if_many_ions(self, fcs, median_fc,ion_diffresults):
        ninety_perc_cutoff = math.ceil(0.9*len(ion_diffresults)) #the ceil function ensures that ions are only excluded if there are more than 10 available
        ion_diffresults = sorted(ion_diffresults, key = lambda _dr : abs(_dr.fc - median_fc))
        if ninety_perc_cutoff >0:
            ion_diffresults = ion_diffresults[:ninety_perc_cutoff]
        median_offset_fc = get_middle_elem(list(map(lambda _dr : _dr.fc,ion_diffresults)))
        return ion_diffresults, median_offset_fc
